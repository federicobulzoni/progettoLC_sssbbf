\subsection{Il modulo di analisi statica}
In questa sezione viene fornita una breve descrizione della logica retrostante il funzionamento del modulo di analisi statica \texttt{StaticAnalysis.hs}.

Il modulo di analisi statica fornisce un'interfaccia alle restanti componenti del compilatore, che permette di ottenere un albero di sintassi astratta annotato ed eventualmente una lista di log a partire da un programma \texttt{Scala40} rappresentato in sintassi astratta.

Per la gestione dei log si rimanda alla sezione riguardante le tecniche non standard utilizzate.

Il modulo è stato progettato seguendo un approccio \textit{top-down}, andando di volta in volta a risolvere i sotto-problemi che ci apparivano dinanzi.

Il modulo di analisi statica fa largo uso del modulo \textit{Environment.hs} che gli offre un'interfaccia per la gestione dell'environment del programma sotto analisi. 

L'environment di un programma è una pila di \textit{scope}, dove ogni scope è formato da: una \textit{tabella di lookup} che mette in corrispondenza gli identificatori definiti all'interno dello scope con le informazioni a riguardo, un \textit{tipo} che eredita dalla funzione in cui lo scope è stato creato ed infine un \textit{valore booleano} che indica se nello scope è presente o meno  un \texttt{return} con tipo compatibile con quello dello scope.

Il modulo \texttt{Environment.hs} fornisce tutte le funzioni necessarie per la gestione dell'environment di un programma. La funzione \texttt{lookup}  permette di ottenere le informazioni a riguardo di un identificatore dichiarato in precedenza nello scope corrente, o in un \textit{super-scope} nel quale lo scope corrente è contenuto; nel caso in cui l'identificatore cercato non sia trovato un eccezione viene ritornata.
La funzione \texttt{update} permette di inserire una nuova corrispondenza \textit{identificatore-info} nello scope corrente, nel caso in cui l'identificatore che si sta cercando di inserire fosse già stato dichiarato in precedenza all'interno dello scope corrente una eccezione viene ritornata.
Per ottenere il tipo dello scope corrente è presente la funzione \textit{getScopeType}, la funzione \textit{hasReturn} ritorna invece il valore booleano che indica se nello scope corrente è presente o meno un \texttt{return} di tipo coerente con quello dello scope; quando un tale \texttt{return} viene trovato la funzione \texttt{setReturnFound} permette di impostare tale valore booleano a \texttt{True}.
La funzione \texttt{addScope} permette di aggiungere un nuovo scope all'environment, la funzione prende come argomento il tipo dello scope che si vuole aggiungere. Qui è importante porsi una domanda:
\begin{center}
Quale tipo viene passato ad \texttt{addScope}?
\end{center}
La risposta è: \textit{dipende}. 
Se lo scope è lo scope globale del programma per una nostra convenzione esso ha tipo \texttt{TSimple\_TypeVoid}; se lo scope viene creato da una dichiarazione di funzione, allora il tipo passato ad \texttt{addScope} è quello della funzione dichiarata; infine se lo scope viene aggiunto dalla creazione di un blocco di statements, allora il tipo passato ad \texttt{addScope} è quello dello scope in cui il blocco di statements è racchiuso.
Non è difficile vedere che tali accorgimenti verificano la proprietà stabilità per il tipo di uno scope, ossia che il tipo di uno scope coincide con il tipo della funzione in cui è racchiuso.

Forniamo ora una breve panoramica del funzionamento del modulo di analisi statica \texttt{StaticAnalysis.hs}. La funzione principale del modulo è \texttt{typeCheck} che preso un programma rappresentato in sintassi astratta di \texttt{Scala40} ritorna tale programma annotato ed eventualmente una lista di log.
Il compito di annotare gli elementi della sintassi astratta e di aggiungere eventuali log alla lista di log ogni qual volta venga rilevata una eccezione è affidato alle funzioni \texttt{infer*} (per esempio: \texttt{inferDecl}, \texttt{inferStm}, \texttt{inferExp}, etc.), tali funzioni preso un elemento della sintassi astratta effettuano i controlli per verificare che tale elemento sia coerente con le specifiche del linguaggio \texttt{Scala40} e nel caso non lo siano tramite la funzione \texttt{saveLog} si occupano di aggiornare la lista di log; al termine dei controlli l'elemento analizzato viene ritornato arricchito con annotazioni quali le informazioni sugli identificatori utilizzati e il tipo delle espressioni coinvolte. 

Le funzioni \texttt{infer*} hanno tutte un comportamento naturalmente ricorsivo, si prenda per esempio il caso di una dichiarazione di variabile con assegnamento di un valore, per poter inferire la dichiarazione e determinare se è valida o meno è necessario inferire l'espressione che si sta cercando di assegnare alla variabile e verificare che i tipi combacino.

Per una nostra decisione personale, nel caso in cui si stia inferendo un elemento che coinvolge una espressione la quale abbiamo già verificato essere problematica, non vengono aggiunte al log nuove eccezioni riguardanti l'elemento sotto-analisi. Questa scelta è giustificata dal desiderio di eliminare ridondanza negli errori, dato che una espressione errata, potrebbe portare ad una lunga serie di errori a catena in tutti gli elementi in cui è compresa.

Per ottenere questo comportamento, abbiamo nella sintassi astratta un tipo interno \texttt{SType\_Error} che viene assegnato alle espressioni che generano un'eccezione, o alle espressioni le cui sotto-espressioni generano eccezioni. Se un qualsiasi elemento ha come sotto-espressione una espressione di tipo \texttt{SType\_Error} non vengono generate ulteriori eccezioni riguardo all'interazione di tale sotto-espressione con l'elemento considerato.

Le annotazioni aggiunte dal modulo di analisi statica riguardano esclusivamente le espressioni, sia R-espressioni (elementi \texttt{Exp}), sia L-espressioni (elementi \texttt{LExp}. Le espressioni annotate sono identificate rispettivamente dagli elementi di sintassi astratta interni: \texttt{ETyped} per le R-espressioni e da \texttt{LExpTyped} per le L-espressioni. Entrambi gli elementi condividono la stessa struttura, una espressione tipata contiene la espressione, il suo tipo, e la locazione in cui viene utilizzata. Un ulteriore caratteristica delle espressioni tipate è che la locazione contenuta all'interno di un identificatore utilizzato all'interno dell'espressione non è la locazione di utilizzo, che invece è in un campo apposito, ma è la locazione di dichiarazione dell'identificatore.
La locazione di dichiarazione di un identificatore utilizzato all'interno di una espressione ci risulta fondamentale per la successiva fase di sgenerazione del codice TAC.
La definizione degli elementi tipati con le loro proprietà è presente all'interno del modulo \texttt{Typed.hs}.



