\subsection{Gestione delle istruzioni TAC tramite la monade State}

Per la gestione della creazione delle istruzioni TAC durante la creazione di quest'ultimo, è stata utilizzata la monade {\tt State a}. Questa permette di manipolare l'inserimento di nuove istruzioni, la creazione di nuove etichette e di nuovi temporanei, in modo equiparabile ad un cambio di stato in una computazione. La creazione e l'inserimento di una nuova istruzione nel codice TAC corrispongono, appunto, ad una modifica dello stato corrente, La monade {\tt State a} utilizza due funzioni per operare su quest'ultimo: {\tt get}, per ottenere lo stato, e {\tt put} per aggiornarlo. 

La monade {\tt State a} utilizzata durante la creazione del Three Address Code opera su stati formati da tuple di otto elementi:
\begin{itemize}
    \item un intero che indica l'indice dell'ultimo temporaneo creato;
    \item un intero che indica l'ultima etichetta creata;
    \item la lista di istruzioni TAC che compongono il TAC in output;
    \item una lista di liste di istruzioni TAC. Ogni lista contiene un insieme di istruzioni di una singola funzione. 
    \item l'etichetta da indicare nel {\tt Goto} in caso venga trovata un'istruzione {\tt continue}. Indica l'etichetta del ciclo corrente nel quale l'istruzione è contenuta. Una volta usciti dal ciclo, l'etichetta viene reipostata a quella precedente, per garantire la correttezza in caso di cicli indeterminati annidati. Quando non ci si trova in un ciclo il valore impostato è quello di un'etichetta fittizia: {\tt Label -1};
    \item l'etichetta da indicare nel {\tt Goto} in caso venga trovata un'istruzione {\tt break}. Per le modalità di utilizzo si rimanda al punto precedente;
    \item un'etichetta che indica la posizione nel flusso della funzione che restituisce l'errore nel caso di discrepanze tra l'indice di accesso ad un array e la dimensione di quest'ultimo;
    \item il tipo di ritorno della funzione. Se non ci si trova in una funzione (scope globale) il valore di default è il tipo {\tt Void}. Questo campo è utile per controllare se vi sia la necessità di eseguire l'operazione di cast sull'espressione ritornata da un eventuale return;
\end{itemize}

Lo stato viene modificato nel momento in cui: si crea una nuova etichetta e/o un nuovo temporaneo tramite le funzioni {\tt newLabel} e {\tt newTemp}, rispettivamente (per evitare duplicazioni tra le istruzioni) e quando una nuova istruzione TAC di una funzione viene inserita nella lista delle istruzioni di quella funzione (tramite la funzione {\tt out}). Vi è una modifica dello stato nel momento in cui tutti gli statetement di una funzione sono stati tradotti in istruzione TAC: l'insieme delle istruzioni di quella funzione vengono aggiunte in testa all'insieme delle istruzioni TAC principale (quelle che compongono il TAC in output), tramite la funzione {\tt pushCurrentStream}.
Inoltre, lo stato si modifica quando vengono modificate le etichette e il tipo (gli ultimi quattro campi dello stato). In particolare la modifica e accesso dell'etichetta per l'istruzione {\tt continue} ({\tt break}) sono, rispettivamente, {\tt setContinue} ({\tt setBreak}) e {\tt getContinue} ({\tt getBreak}). L'etichetta della funzione di controllo degli array viene gestita tramite le funzioni {\tt setOutOfBounds} e {\tt getOutOfBounds}; mentre l'ultimo campo viene manipolato tramite le funzioni {\tt setFunType} e {\tt getFunType}.

Tutte queste funzioni servono per modificare lo stato ed ottenere da esso il valore attuate di quello specifico campo.
Nel file {\tt StateManager.hs} sono presenti tutte le funzioni di manipolazione dello stato ed è stato utilizzato {\tt TacState a} come alias per {\tt State (Int, Int, [TAC], [[TAC]], Label, Label, Label, TypeSpec) a}, dove {\tt TAC} è un'istruzione TAC.