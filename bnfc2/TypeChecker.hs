module TypeChecker where

-- Haskell module generated by the BNF converter

import AbsGramm
import ErrM
import Environment as Env
import PrintGramm
import Control.Monad.Writer

-- DefFun PIdent [ParamClause] TypeSpec Body
{-
type Env = Map.Map Ident Info
data Info = 
  VarInfo Loc Type
  | FunInfo Loc Type [ParamClause]
  deriving (Show)

update :: EnvStack -> Ident -> Info -> Err EnvStack
-}


initialFuns :: [(Ident, Info)]
initialFuns = [("writeInt", FunInfo (0,0) (TSimple TypeVoid) [PArg [DArg (PIdent ((0,0),"i")) (TSimple SType_Int) ]]),
  ("writeFloat", FunInfo (0,0) (TSimple TypeVoid) [PArg [DArg (PIdent ((0,0),"f")) (TSimple SType_Float) ]]),
  ("writeChar", FunInfo (0,0) (TSimple TypeVoid) [PArg [DArg (PIdent ((0,0),"c")) (TSimple SType_Char) ]]),
  ("writeString", FunInfo (0,0) (TSimple TypeVoid) [PArg [DArg (PIdent ((0,0),"s")) (TSimple SType_String) ]]),

  ("readInt", FunInfo (0,0) (TSimple SType_Int) [PArg []]),
  ("readFloat", FunInfo (0,0) (TSimple SType_Float) [PArg []]),
  ("readChar", FunInfo (0,0) (TSimple SType_Char) [PArg []]),
  ("readString", FunInfo (0,0) (TSimple SType_String) [PArg []]) ]

typeCheck :: Program -> Writer [String] Program
typeCheck (Prog decls) = do
  -- deve inizializzare l'environment.
  let x = foldM (\x (ident, info) -> Env.update x ident info) Env.emptyStack initialFuns in
    case x of
      Ok env -> do
        res <- checkDecls decls env
        return (Prog res)
      Bad msg -> do
        -- è impossibile.
        error $ msg

checkDecls :: [Decl] -> Env -> Writer [String] [Decl]
checkDecls [] env = return []
checkDecls (decl:decls) env = do
 (decl' , env') <-  checkDecl decl env
 xs <- checkDecls decls env'
 return (decl':xs)

checkDecl :: Decl -> Env -> Writer [String] (Decl, Env)
checkDecl decl env = case decl of
  --  DecVar Id Type
  DecVar id typ -> let x = updateVar env id typ in
    case x of
      Ok env' -> return (decl, env')
      Bad msg -> do
        tell [msg]
        return (decl, env)
  --  DefVar Id Type Exp
  DefVar id typ exp -> let x = updateVar env id typ in
    case x of
      Ok env' -> do
        -- Teniamo il vecchio env, perchè altrimenti si potrebbe usare nella parte destra della dichiarazione
        -- la variabile che si sta istanziando.
        texp <- checkExp exp typ env
        return ((DefVar id typ texp), env')
      Bad msg -> do
        tell [msg]
        return (decl, env)

-- OK!!!
{-


-}


checkExp :: Exp -> Type -> Env -> Writer [String] Exp
checkExp exp typ env = do
  typ' <- inferExp exp env
  if typ' == Type_null
    then
      return (ETyped exp Type_null)
    else 
      if (checkExpAux typ typ')
        then
          return (ETyped exp typ)
        else
          do 
            tell [printTree exp ++ " e' di tipo " ++ printTree typ' ++ ", ma il tipo aspettato e' " ++ printTree typ ++ "\n"]
            return (ETyped exp Type_null)


checkExpAux :: Type -> Type -> Bool
checkExpAux typ typ'
  | typ' == typ = True
  | otherwise = False

-- OK!!!
{-
data Exp
    = EArray [Exp]
    | ENot Exp
    | ENeg Exp
    | ELExp LExp
    | EDeref LExp
    | EInt PInteger
    | EFloat PFloat
    | EChar PChar
    | EString PString
    | ETrue PTrue
    | EFalse PFalse
    | ENull PNull
    | EOp Exp Op Exp
    | ETyped Exp TypeSpec
    | EVarTyped PIdent TypeSpec PInteger PInteger
  deriving (Eq, Ord, Show, Read)
-}


-- (not (3+5)) -> Type_error
-- (3+5) -> Type_Int
inferExp :: Exp -> EnvStack -> Writer [String] Type
inferExp exp env = case exp of
  -- Nel caso dell'array bisogna inferire il tipo di ogni espressione in exps
  -- e tutte devono avere lo stesso tipo.
  -- Caso con array vuoto.
  EArray [] -> return TypeVoid
  -- Caso con almeno un elemento
  EArray [exp'] -> inferExp exp' env
  EArray (exp':exps) -> do
    typ' <- inferExp exp' env
    checkExp (EArray exps) typ' env

  -- Il not non cambia il tipo dell'espressione a cui è applicato,
  -- il tipo di una espressione not è dunque il tipo della espressione a cui il not è applicato.
  ENot exp' -> checkExp exp' SType_Bool env
    
  --Stesso discorso del not.
  ENeg exp' -> inferExp exp' env

  -- Stesso discorso del not e del neg.
  ELExp exp' -> inferExp exp' env

  EAdd exp1 exp2 -> do 
    -- Writer [String] Type
    t1 <- inferExp exp1 env
    t2 <- inferExp exp2 env

    case (t1,t2) of
      (_, Type_null) -> return Type_null
      (Type_null, _) -> return Type_null
      (x, y) -> if x == y
        then 
          return t1
        else
          do
            tell ["operatori di tipo diverso: " ++ printTree exp1 ++ " ha tipo: " ++ show t1 ++ ", " ++ printTree exp2 ++ " ha tipo: " ++ show t2 ++ ".\n"]
            return Type_null
  EInt n -> return Type_int
  EVar id -> let t1 = lookupVar env id in
    case t1 of
      Bad msg -> do
        tell [msg]
        return Type_null
      Ok typ -> return typ








-- Tests:
getEnv = do 
  env1 <- updateVar emptyEnv (Id ((1,5),"x")) Type_int
  updateVar env1 (Id ((1,22),"y")) Type_float


test4 :: Writer [String] (Decl, Env)
test4 = let x = getEnv
  in
    case x of
      Ok env -> checkDecl (DefVar (Id ((1,5),"z")) Type_int (EAdd (EVar (Id ((1,49),"y"))) (EVar (Id ((1,51),"x"))))) env
      Bad _ -> error $ "ciao"

test5 = let x = getEnv
  in 
    case x of
      Ok env -> checkDecl (DefVar (Id ((1,5),"x")) Type_int (EAdd (EVar (Id ((1,49),"y"))) (EVar (Id ((1,51),"x"))))) env
      Bad _ -> error $ "ciao"


test3 = let x = getEnv 
  in
    case x of
      Ok env -> checkExp (EAdd (EVar (Id ((1,49),"y"))) (EVar (Id ((1,51),"x")))) Type_float env
      Bad _ -> return (ETyped  (EVar (Id ((1,49),"crocs"))) Type_null)



test2 = let x = getEnv
  --updateVar (updateVar emptyEnv (Id ((1,5),"x")) Type_int) (Id ((1,22),"y")) Type_int
  in 
    case x of
      Ok env -> inferExp (EAdd (EVar (Id ((1,49),"x"))) (EVar (Id ((1,51),"y")))) env
      Bad msg -> return Type_int

test = let x = updateVar emptyEnv (Id ((3,5), "y")) Type_int in
  case x of
    Ok env -> inferExp (EVar (Id ((1,2), "x"))) env
    Bad msg -> return Type_int
--updateVar emptyEnv (Id ((3,5), "x")) Type_int >>= inferExp (EVar (Id ((1,2), "x")))

    


