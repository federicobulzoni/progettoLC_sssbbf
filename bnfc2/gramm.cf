-- Per avere liste non vuote c'è la parola nonempty: terminator nonempty Def "";
-- Per ricordare la posizione di un token: position token PIdent.
entrypoints Program;

position token PIdent ( letter (letter | digit | '_' )* );
					-- Sia parte int che decim. Solo int.   Solo decim.
position token PFloat ( (digit+ '.' digit+) | (digit+ '.') | ('.' digit+));
position token PInteger ( digit+ );
--position token PString ( '"' ((char - ["\"\\"]) | ('\\' ["\"\\nt"]))* '"' );
--position token PChar ('\'' ((char - ["'\\"]) | ('\\' ["'\\nt"])) '\'' );

comment "//";
comment "/*" "*/";


Prog. Program ::= [Declaration];
separator Declaration ";";
separator Declaration "\n";
terminator Declaration "";

TSimple. TypeSpec ::= SType ;
-- Problema durante il parsing se ci sono più &..& consecutive.
TPointer. TypeSpec ::= "&" TypeSpec;
-- Questa è una nostra versione speciale, degli array,
-- abbiamo fatto così perchè scala non ha i puntatori, ma 
-- noi avendoli avevamo problemi con il dichiarare puntatori
-- ad array, dato che la dichiarazione degli array,
-- ha una sintassi speciale che non utilizza i ':', bensì '='.
TArray. TypeSpec ::= "Array" "[" Exp "]" "(" TypeSpec ")";

rules SType ::= "float" | "int" | "char" | "string" | "bool" | "null" ;

DecVar. Declaration ::= "var" PIdent ":" TypeSpec;
DefVar. Declaration ::= "var" PIdent ":" TypeSpec "=" Exp;
-- La espressione nella dichiarazione di array ne determina la dimensione
-- segue, che tale espressione deve avere tipo Intero.
-- Il tipo dell'array è il tipo delle espressioni che gli sono assegnate,
-- tutte le espressioni devono avere stesso tipo.
DefArray. Declaration ::= "var" PIdent "=" "Array" "("[Exp]")";
separator Exp ",";
terminator Exp ""; 
-- Tutti i nostri Exp corrispondono agli RExpr del Prof.

-- Dichiarazioni di funzioni/procedure.
-- Non abbiamo liste di liste di argomenti, 
-- è una nostra scelta quella di mantenere una lista,
-- unica.
DefProc. Declaration ::= "def" PIdent "(" [Arg] ")" "=" Body;
--DefFun. Declaration ::= "def" PIdent "(" [Arg] ")" ":" RetType;
EBody. Body ::= Exp;
BBody. Body ::= Block;

separator  Arg ",";
terminator Arg "";

DArg. Arg ::= PIdent ":" Type;

_. Op ::= Op1;
_. Op ::= Op2;


-- LAss
Or. Op1 ::= "||";
And. Op2 ::= "&&";
--Not. Op3 ::= "!";

-- Tutti questi (i 4) sono non associativi.
Less. Op4 ::= "<";
LessEq. Op4 ::= "<=";
Greater. Op4 ::= ">";
GreterEq. Op4 ::= ">=";
-- Le stringhe si può controllare che siano uguali o diverse.
Equal. Op4 ::= "==";
NotEq. Op4 ::= "!=";

-- LAss.
Plus. Op5 ::= "+";
Minus. Op5 ::= "-";
Prod. Op6 ::= "*";
Div. Op6 ::= "/";
Mod. Op6 ::= "%";

-- RAss.
Pow. Op7 ::= "^"; 
-- Unario
--Neg. Op8 ::= "-";

coercions Op 8;


-- Ci va EArray???
EArray. Exp ::= "Array" "("[Exp]")";
-- OR
op. Exp ::= Exp Op1 Exp1;
op. Exp1 ::= Exp1 Op2 Exp2;
-- Diamo il permesso di mettere più negazioni.
ENot. Exp2 ::= "!" Exp2;

op. Exp3 ::= Exp4 Op4 Exp4;

op. Exp4 ::= Exp4 Op5 Exp5;
op. Exp5 ::= Exp5 Op6 Exp6;

op. Exp6 ::= Exp7 Op7 Exp6;
ENeg. Exp7 ::= "-" Exp8;
-- Dereferenziazione
EDeref. Exp8 ::= "&" Exp8;
-- Referenziazione.
ERef. Exp8 ::= "*" Exp8;

EInt. Exp8 ::= PInteger  ;
EFloat. Exp8 ::= PFloat ;
EVar. Exp8 ::= PIdent ; 
EChar. Exp8 ::= PChar ;
EString. Exp8 ::= PString ;
ETrue. Exp8 ::= "true";
EFalse. Exp8 ::= "false";



coercions Exp 8 ; 
-- LExp è qualcosa che ha un indirizzo e quindi gli possiamo assegnare un valore.
-- RExp è un qualcosa che valutata ci da un valore.
-- Le REXp corrispondono nel nostro Exp.

internal EOp. Exp ::= Exp8 Op Exp8;
--internal UEOp. Exp ::= Op8 Exp8;
define op e1 o e2 = EOp e1 o e2;
--define opU o e = UEOp o e;


terminator Stm "";
separator Stm ";";

rules Type ::= "float" | "int" | "char" | "string" | "bool" | "null" ;

Decla. Stm ::= Declaration;
Expr. Stm ::= Exp;
SBlock. Stm ::= Block;


Assign. Stm ::= PIdent "=" Exp;
DBlock. Block ::= "{" [Stm] "}" ;
While. Stm ::= "while" "(" Exp ")" Stm ;
If. Stm ::= "if" "(" Exp ")" Stm "else" Stm ;
--internal Loc. Loc ::= "(" PInteger "," PInteger ")";
internal ETyped. Exp ::= "[" Exp ":" Type "]" ;
-- La seconda coppia è la posizione corrispondente a dove la variabile id è stata dichiarata.
internal EVarTyped. Exp2 ::= "[" PIdent ":" Type "," "(" PInteger "," PInteger ")" "]";
