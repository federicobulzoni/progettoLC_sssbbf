-- Per avere liste non vuote c'è la parola nonempty: terminator nonempty Def "";
-- Per ricordare la posizione di un token: position token PIdent.
entrypoints Program;


position token PTrue	'T' 'r' 'u' 'e' ;						
position token PFalse	'F' 'a' 'l' 's' 'e' ;						
position token PReturn	'r' 'e' 't' 'u' 'r' 'n' ;	
position token PNull	'N' 'u' 'l' 'l';			
position token PIdent ( letter (letter | digit | '_' )* );
					-- Sia parte int che decim. Solo int.   Solo decim.
position token PFloat ( (digit+ '.' digit+) | (digit+ '.') | ('.' digit+));
position token PInteger ( digit+ );

comment "//";
comment "/*" "*/";

Prog. Program ::= [Declaration];
separator	Declaration ";";
separator	Declaration "\n";
terminator	Declaration ";";
terminator	Declaration "";

TSimple.	TypeSpec ::= SType ;
TPointer.	TypeSpec ::= "*" TypeSpec;
-- Questa è una nostra versione speciale, degli array,
-- abbiamo fatto così perchè scala non ha i puntatori, ma 
-- noi avendoli avevamo problemi con il dichiarare puntatori
-- ad array, dato che la dichiarazione degli array,
-- ha una sintassi speciale che non utilizza i ':', bensì '='.

-- Rimane il dubbio se mettere Exp o PInteger
TArray. TypeSpec ::= "Array" "[" TypeSpec "]" "(" Exp ")";

rules SType ::= "Float" | "Int" | "Char" | "String" | "Bool";
-- Da considerare se renderlo disponibile all'utente o tenerlo solo interno.
-- TypeError viene assegnato ogni volta che il type checker da errore al corrispondente elemento della sintassi astratta
-- tale elemento può essere una espressione, ma anche una funzione con problemi sul tipo di ritorno ad esempio.
internal TypeError.	SType ::= "Error";
-- TypeVoid è il tipo fittizio assegnato alle procedure e degli array vuoti.
internal TypeVoid.	SType ::= "Void";

DecVar. Declaration ::= "var" PIdent ":" TypeSpec;
DefVar. Declaration ::= "var" PIdent ":" TypeSpec "=" Exp;
-- La espressione nella dichiarazione di array ne determina la dimensione
-- segue, che tale espressione deve avere tipo Intero.
-- Il tipo dell'array è il tipo delle espressioni che gli sono assegnate,
-- tutte le espressioni devono avere stesso tipo.

-- La definizione di Array è ridondante, infatti, basta mettere Array(Exp) come RExp.
-- DefArray. Declaration ::= "var" PIdent "=" "Array" "("[Exp]")";

-- Tutti i nostri Exp corrispondono agli RExpr del Prof.

-- Dichiarazioni di funzioni/procedure.
-- Non abbiamo liste di liste di argomenti, 
-- è una nostra scelta quella di mantenere una lista,
-- unica.
dproc. 			Declaration ::= "def" PIdent [ParamClause] "=" Block;
DefFun.  		Declaration ::= "def" PIdent [ParamClause] ":" TypeSpec "=" Block;
DefFunInLine. 	Declaration ::= "def" PIdent [ParamClause] ":" TypeSpec "=" Exp;

PArg. ParamClause ::= "("  [Arg] ")";

separator nonempty ParamClause "";
terminator nonempty ParamClause ""; 
separator  Arg ",";
terminator Arg "";

DBlock. 				Block ::= "{" [Stm] "}" ;
internal BlockTyped. 	Block ::= "[" Block ":" TypeSpec "]"; 
--DefFun. Declaration ::= "def" PIdent "(" [Arg] ")" ":" RetType;
--EBody. Body ::= Exp;
-- Nel blocco/stmt deve esserci il return, ma questo lo controlla il TypeChecker.
-- ha senso mettere un singolo statement? (che poi si può riscrivere in un blocco comunque).
--SBody. Body ::= Block;
DArg. Arg ::= PIdent ":" TypeSpec;

-- LAss
Or. 		Op1 ::= "||";
And. 		Op2 ::= "&&";
-- Tutti questi (i 4) sono non associativi.
Less. 		Op3 ::= "<";
LessEq. 	Op3 ::= "<=";
Greater. 	Op3 ::= ">";
GreterEq. 	Op3 ::= ">=";
-- Le stringhe si può controllare che siano uguali o diverse.
Equal. 		Op3 ::= "==";
NotEq. 		Op3 ::= "!=";
-- LAss.
Plus. 		Op4 ::= "+";
Minus. 		Op4 ::= "-";
Prod. 		Op5 ::= "*";
Div. 		Op5 ::= "/";
Mod. 		Op5 ::= "%";
-- RAss.
Pow. 		Op6 ::= "^"; 

coercions Op 6;


-- Ci va per l'inizializzazione degli array.
EArray. Exp ::= "Array" "("[Exp]")";
separator Exp ",";
terminator Exp ""; 

-- Lista di RExp.
op. 		Exp ::= Exp Op1 Exp1;
op. 		Exp1 ::= Exp1 Op2 Exp2;
-- Diamo il permesso di mettere più negazioni.
ENot. 		Exp2 ::= "!" Exp2;
op. 		Exp2 ::= Exp3 Op3 Exp3;

op. 		Exp3 ::= Exp3 Op4 Exp4;
op. 		Exp4 ::= Exp4 Op5 Exp5;

op. 		Exp5 ::= Exp6 Op6 Exp7;
ENeg. 		Exp6 ::= "-" Exp7;

-- Exp si riscrive in LExp, dato che le LExp identificano sempre delle variabili/indirizzi/array e per tanto possono 
-- anche essere assegnati.
ELExp. 		Exp7 ::= LExp;
EDeref. 	Exp7 ::= "&" LExp;
-- I valori costanti sono invece questi.
EInt. 		Exp7 ::= PInteger  ;
EFloat. 	Exp7 ::= PFloat ;
EChar. 		Exp7 ::= PChar ;
EString.	Exp7 ::= PString ;
ETrue. 		Exp7 ::= PTrue;
EFalse. 	Exp7 ::= PFalse;
ENull. 		Exp7 ::= PNull;

coercions Exp 7 ; 
-- LExp è qualcosa che ha un indirizzo e quindi gli possiamo assegnare un valore.
-- RExp è un qualcosa che valutata ci da un valore.
-- Le REXp corrispondono nel nostro Exp.

internal EOp. Exp ::= Exp7 Op Exp7;

SDecl. 		Stm ::= Declaration;
SBlock. 	Stm ::= Block;
SAssign. 	Stm ::= LExp "=" Exp;
SWhile. 	Stm ::= "while" "(" Exp ")" Stm ;
SIf. 		Stm ::= "if" "(" Exp ")" Stm "else" Stm ;
-- Il do è da ragionarci sopra dato che si riscrive in un blocco, bensì che è uno statement singolo in realtà.
sdo. 		Stm ::= "do" Stm "while" "(" Exp ")";
SReturn. 	Stm ::= PReturn ;
SReturnExp. Stm ::= PReturn Exp ;

separator 	Stm ";";
separator 	Stm "\n";
terminator 	Stm ";";
terminator 	Stm "";

internal StmTyped. Stm ::= "[" Stm ":" TypeSpec "]";
-- Lista di LExp.
LRef. 	LExp ::= "*" LExp;
-- Da verificare se le parentesi tonde creano conflitti con le espressioni e con le precedenze definite dall'utente
-- nella valutazione dei puntatori.
LArr. 	LExp1 ::= LExp1 "(" Exp ")";
LIdent. LExp1 ::= PIdent;
coercions LExp 2;

internal LExpTyped.		LExp ::= "[" LExp ":" TypeSpec ":" "(" Integer "," Integer ")" "]";
--internal Loc. Loc ::= "(" PInteger "," PInteger ")";
internal ETyped.		Exp ::= "[" Exp ":" TypeSpec ":" "(" Integer "," Integer")" "]" ;
-- La seconda coppia è la posizione corrispondente a dove la variabile id è stata dichiarata.
internal LIdentTyped.	LExp ::= "[" PIdent ":" TypeSpec ":" "(" Integer "," Integer ")" "]";
--DefFun.  Declaration ::= "def" PIdent [ParamClause] ":" TypeSpec "=" Body;

-- Cose che non vanno bene a Sublime.
define op e1 o e2 = EOp e1 o e2;
define sdo st ex = SBlock (DBlock [st, (SWhile ex st)]);
define dproc id params block = DefFun id params (TSimple TypeVoid) (block);
-- define defFunInLine id params typ exp = DefFun id params typ (DBlock [SReturnExp (PReturn ( (0,0) , "return")) exp]);
position token PString ( '"' ((char - ["\"\\"]) | ('\\' ["\"\\nt"]))* '"' );
position token PChar ('\'' ((char - ["'\\"]) | ('\\' ["'\\nt"])) '\'' );

